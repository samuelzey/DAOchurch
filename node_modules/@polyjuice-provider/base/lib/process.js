"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSerializeAddressMappingAbiItem = exports.buildProcess = exports.buildEstimateGasTransaction = exports.executeCallTransaction = exports.buildSendTransaction = exports.ProcessTransactionType = void 0;
const util_1 = require("./util");
const abi_1 = require("./abi");
const types_1 = require("./types");
const constant_1 = require("./constant");
var ProcessTransactionType;
(function (ProcessTransactionType) {
    ProcessTransactionType[ProcessTransactionType["send"] = 0] = "send";
    ProcessTransactionType[ProcessTransactionType["call"] = 1] = "call";
    ProcessTransactionType[ProcessTransactionType["estimateGas"] = 2] = "estimateGas";
})(ProcessTransactionType = exports.ProcessTransactionType || (exports.ProcessTransactionType = {}));
async function buildSendTransaction(abi, godwoker, tx, signingMethod, signingMessageType) {
    const process = {
        type: ProcessTransactionType.send,
        signingMethod: signingMethod,
        signingMessageType: signingMessageType,
    };
    const serializeTx = await buildProcess(abi, godwoker, tx, process);
    if (typeof serializeTx !== "string")
        throw new Error("build sendTransaction end up with non-string type return!");
    return serializeTx;
}
exports.buildSendTransaction = buildSendTransaction;
async function executeCallTransaction(abi, godwoker, tx) {
    const process = {
        type: ProcessTransactionType.call,
    };
    const callReturnData = await buildProcess(abi, godwoker, tx, process);
    if (typeof callReturnData !== "string")
        throw new Error("execute callTransaction end up with non-string return!");
    return callReturnData;
}
exports.executeCallTransaction = executeCallTransaction;
async function buildEstimateGasTransaction(abi, godwoker, tx) {
    const process = {
        type: ProcessTransactionType.call,
    };
    const rawL2Tx = await buildProcess(abi, godwoker, tx, process);
    if (typeof rawL2Tx === "string")
        throw new Error("build estimateGasTransaction end up with string return!");
    if (!isRawL2Transaction(rawL2Tx))
        throw new Error("build estimateGasTransaction end up with invalid RawL2Transaction type return!");
    return rawL2Tx;
}
exports.buildEstimateGasTransaction = buildEstimateGasTransaction;
async function buildProcess(abi, godwoker, tx, process) {
    if (!tx.from && process.type === ProcessTransactionType.send) {
        throw new Error("tx.from can not be missing in sendTransaction!");
    }
    if (!process.signingMethod && process.type === ProcessTransactionType.send) {
        throw new Error("process.signingMethod can not be missing in sendTransaction!");
    }
    if (process.type === ProcessTransactionType.estimateGas &&
        !process.executeEstimateGasMethod) {
        throw new Error("executeEstimateGasMethod can not be missing in estimateGas!");
    }
    tx.from = tx.from || (await godwoker.getPolyjuiceDefaultFromAddress());
    let addressMappingItemVec = [];
    function setAddressMappingItemVec(_addressMappingItemVec) {
        addressMappingItemVec = _addressMappingItemVec;
    }
    let dataWithShortAddress;
    dataWithShortAddress = await abi.refactor_data_with_short_address(tx.data, godwoker.getShortAddressByAllTypeEthAddress.bind(godwoker), setAddressMappingItemVec);
    const t = util_1.normalizeEthTransaction({
        from: tx.from,
        to: tx.to,
        value: tx.value,
        gas: tx.gas,
        gasPrice: tx.gasPrice,
        data: dataWithShortAddress,
    });
    const rawL2Tx = await godwoker.assembleRawL2Transaction(t);
    switch (process.type) {
        case ProcessTransactionType.send: {
            const signingMessageType = process.signingMessageType || types_1.SigningMessageType.withPrefix;
            const message = await godwoker.generateMessageFromEthTransaction(t, signingMessageType);
            const _signature = await process.signingMethod(message);
            const signature = godwoker.packSignature(_signature);
            const l2Tx = { raw: rawL2Tx, signature: signature };
            let serializedAbiItem = buildSerializeAddressMappingAbiItem(abi, dataWithShortAddress);
            const polyL2Tx = util_1.buildL2TransactionWithAddressMapping(l2Tx, addressMappingItemVec, serializedAbiItem);
            return godwoker.serializeL2TransactionWithAddressMapping(polyL2Tx);
        }
        case ProcessTransactionType.call: {
            let serializedAbiItem = buildSerializeAddressMappingAbiItem(abi, dataWithShortAddress);
            const polyRawL2Tx = util_1.buildRawL2TransactionWithAddressMapping(rawL2Tx, addressMappingItemVec, serializedAbiItem);
            const run_result = await godwoker.poly_executeRawL2Transaction(polyRawL2Tx);
            const abi_item = abi.get_interested_abi_item_by_encoded_data(tx.data);
            if (!abi_item)
                return run_result.return_data;
            return await abi.refactor_return_value_with_short_address(run_result.return_data, abi_item, godwoker.getEthAddressByAllTypeShortAddress.bind(godwoker));
        }
        case ProcessTransactionType.estimateGas: {
            return rawL2Tx;
        }
        default:
            throw new Error("unknown process type!");
    }
}
exports.buildProcess = buildProcess;
function buildSerializeAddressMappingAbiItem(abi, data) {
    const abiItem = abi.get_interested_abi_item_by_encoded_data(data);
    if (!abiItem)
        return constant_1.EMPTY_ABI_ITEM_SERIALIZE_STR;
    const abiInputs = abi.filter_interested_inputs(abiItem);
    if (abiInputs.length === 0)
        return constant_1.EMPTY_ABI_ITEM_SERIALIZE_STR; // we only want abiItem with interested inputs not outputs
    const _abiItem = Object.assign({}, abiItem); // do not change the original abi object
    return abi_1.serializeAbiItem(_abiItem);
}
exports.buildSerializeAddressMappingAbiItem = buildSerializeAddressMappingAbiItem;
function isRawL2Transaction(value) {
    return (value.from_id != undefined &&
        value.to_id != undefined &&
        value.nonce != undefined &&
        value.args != undefined);
}
//# sourceMappingURL=process.js.map