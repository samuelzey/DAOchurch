import { Script, Hash, HexNumber, HexString } from "@ckb-lumos/base";
import { RawL2Transaction, L2Transaction, RunResult, TransactionReceipt as GwTransactionReceipt } from "@polyjuice-provider/godwoken";
import { AddressMapping, RawL2TransactionWithAddressMapping, L2TransactionWithAddressMapping, AddressMappingItem } from "@polyjuice-provider/godwoken/lib/addressTypes";
import { ShortAddress, SigningMessageType } from "./types";
declare global {
    interface Window {
        fetch: any;
    }
}
export interface EthTransactionReceipt {
    transactionHash: Hash;
    blockHash: Hash;
    blockNumber: HexNumber;
    transactionIndex: HexNumber;
    gasUsed: HexNumber;
    cumulativeGasUsed: HexNumber;
    logsBloom: HexString;
    logs: EthLogItem[];
    contractAddress: HexString;
    status: EthTransactionStatus;
}
export interface EthLogItem {
    address: HexString;
    blockHash: Hash;
    blockNumber: HexNumber;
    transactionIndex: HexNumber;
    transactionHash: Hash;
    data: HexString;
    logIndex: HexNumber;
    topics: HexString[];
    removed: boolean;
}
export declare enum EthTransactionStatus {
    success = "0x1",
    failure = "0x0"
}
export declare type EthAddress = HexString;
export declare type EthTransaction = {
    from: HexString;
    to: HexString;
    gas?: HexNumber;
    gasPrice?: HexNumber;
    value: HexNumber;
    data: HexString;
    nonce?: HexNumber;
};
export declare type InformalEthTransaction = {
    from?: HexString;
    to?: HexString;
    gas?: HexNumber | bigint | number;
    gasLimit?: HexNumber | bigint | number;
    gasPrice?: HexNumber | bigint | number;
    value?: HexNumber | bigint | number;
    data?: HexString;
    nonce?: HexNumber | bigint | number;
};
export declare type L2TransactionArgs = {
    to_id: number;
    value: bigint;
    data: HexString;
};
export declare type GodwokerOption = {
    godwoken?: {
        rollup_type_hash?: Hash;
        eth_account_lock?: Omit<Script, "args">;
    };
    queryEthAddressByShortAddress?: (short_address: string) => string;
    saveEthAddressShortAddressMapping?: (eth_address: string, short_address: string) => void;
    request_option?: object;
};
export declare type RequestRpcResult = {
    err: any;
    data?: string;
};
export declare enum RequireResult {
    canBeEmpty = 0,
    canNotBeEmpty = 1
}
export declare function formalizeEthToAddress(to_address: string | undefined | null): string;
export declare function verifyHttpUrl(_url: string): boolean;
export declare function isHexString(value: any, length?: number): boolean;
export declare function normalizeHexValue(value: HexNumber | bigint | number): HexString;
export declare function normalizeEthTransaction(tx: InformalEthTransaction): {
    from: string;
    to: string;
    gas: string;
    gasPrice: string;
    value: string;
    data: string;
};
export declare function serializeAddressMapping(addressMapping: AddressMapping): HexString;
export declare function deserializeAddressMapping(value: HexString): AddressMapping;
export declare function serializeRawL2TransactionWithAddressMapping(rawL2TransactionWithAddressMapping: RawL2TransactionWithAddressMapping): HexString;
export declare function deserializeRawL2TransactionWithAddressMapping(value: HexString): RawL2TransactionWithAddressMapping;
export declare function serializeL2TransactionWithAddressMapping(l2TransactionWithAddressMapping: L2TransactionWithAddressMapping): HexString;
export declare function deserializeL2TransactionWithAddressMapping(value: HexString): L2TransactionWithAddressMapping;
export declare function buildL2TransactionWithAddressMapping(tx: L2Transaction, addressMappingItemVec: AddressMappingItem[], abiItem?: HexString): L2TransactionWithAddressMapping;
export declare function buildRawL2TransactionWithAddressMapping(tx: RawL2Transaction, addressMappingItemVec: AddressMappingItem[], abiItem?: HexString): RawL2TransactionWithAddressMapping;
export declare function serializeL2Transaction(tx: L2Transaction): HexString;
export declare function serializeRawL2Transaction(tx: RawL2Transaction): HexString;
export declare function decodeArgs(_args: HexString): {
    header: string;
    type: string;
    gas_limit: string;
    gas_price: string;
    value: string;
    data_length: string;
    data: string;
};
export declare function encodeArgs(_tx: EthTransaction): string;
export declare class Godwoker {
    private eth_account_lock;
    private rollup_type_hash;
    private client;
    private godwokenUtils;
    private queryEthAddressByShortAddress;
    private saveEthAddressShortAddressMapping;
    constructor(host: string, option?: GodwokerOption);
    init(): Promise<void>;
    initSync(): Promise<void>;
    packSignature(_signature: HexString): HexString;
    jsonRPC(method: string, params: any[], _errMsgWhenNoResult?: string | null, requireResult?: RequireResult): Promise<any>;
    computeScriptHashByEoaEthAddress(eth_address: string): HexString;
    getScriptByScriptHash(_script_hash: string): Promise<Script>;
    getScriptHashByAccountId(account_id: number): Promise<HexString>;
    getAccountIdByScriptHash(script_hash: string): Promise<HexNumber>;
    getAccountIdByEoaEthAddress(eth_address: string): Promise<HexNumber>;
    getScriptHashByShortAddress(_address: string, requireResult?: RequireResult): Promise<HexString>;
    computeShortAddressByEoaEthAddress(_address: string): HexString;
    getShortAddressByAllTypeEthAddress(_address: string): Promise<ShortAddress>;
    getEthAddressByAllTypeShortAddress(_short_address: HexString): Promise<HexString>;
    isShortAddressOnChain(short_address: HexString): Promise<boolean>;
    checkEthAddressIsEoa(eth_address: string, _target_short_address: string): boolean;
    defaultQueryEthAddressByShortAddress(_short_address: string): Promise<HexString>;
    getNonce(account_id: number): Promise<HexNumber>;
    assembleRawL2Transaction(eth_tx: EthTransaction): Promise<RawL2Transaction>;
    generateTransactionMessageToSign(tx: RawL2Transaction, sender_script_hash: string, receiver_script_hash: string, is_add_prefix_in_signing_message?: boolean): string;
    generateMessageFromEthTransaction(tx: EthTransaction, msg_type?: SigningMessageType): Promise<string>;
    serializeL2Transaction(tx: L2Transaction): HexString;
    serializeRawL2Transaction(tx: RawL2Transaction): HexString;
    serializeL2TransactionWithAddressMapping(tx: L2TransactionWithAddressMapping): HexString;
    serializeRawL2TransactionWithAddressMapping(tx: RawL2TransactionWithAddressMapping): HexString;
    gw_executeL2Transaction(raw_tx: RawL2Transaction, signature: HexString): Promise<RunResult>;
    gw_executeRawL2Transaction(raw_tx: RawL2Transaction): Promise<RunResult>;
    poly_executeRawL2Transaction(raw_tx: RawL2TransactionWithAddressMapping): Promise<RunResult>;
    gw_submitL2Transaction(raw_tx: RawL2Transaction, signature: HexString): Promise<Hash>;
    gw_submitSerializedL2Transaction(serialize_tx: HexString): Promise<Hash>;
    poly_submitL2Transaction(l2_tx: L2TransactionWithAddressMapping): Promise<Hash>;
    poly_submitSerializedL2Transaction(serialize_tx: HexString): Promise<Hash>;
    gw_getTransactionReceipt(tx_hash: Hash): Promise<GwTransactionReceipt | null>;
    getRollupTypeHash(): Promise<HexString>;
    getEthAccountLockHash(): Promise<HexString>;
    getContractValidatorHash(): Promise<HexString>;
    getPolyjuiceCreatorAccountId(): Promise<HexNumber>;
    getPolyjuiceDefaultFromAddress(): Promise<HexString>;
    eth_getTransactionReceipt(tx_hash: Hash): Promise<EthTransactionReceipt | null>;
    waitForTransactionReceipt(tx_hash: Hash, timeout?: number, loopInterval?: number): Promise<void>;
    asyncSleep(ms?: number): Promise<unknown>;
    allTypeEthAddressToAccountId(_address: HexString): Promise<HexNumber>;
}
export declare function UInt32ToLeBytes(num: number): HexString;
export declare function UInt64ToLeBytes(num: bigint): HexString;
export declare function UInt128ToLeBytes(u128: bigint): HexString;
export declare function LeBytesToUInt32(hex: HexString): number;
export declare function LeBytesToUInt64(hex: HexString): bigint;
export declare function LeBytesToUInt128(hex: HexString): bigint;
